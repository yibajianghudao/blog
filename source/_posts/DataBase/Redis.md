---
title: Redis
date: 2025-08-18 00:55:37
tags:
---

# Redis

## 缓存防护

### 缓存穿透

### 缓存击穿

### 缓存雪崩



## 热key(hostkey)

### 热key的识别与利用

整体思路是通过冷启动预热+动态识别保障热点数据进入 Redis，再利用淘汰策略保证有限空间内的热度最大化，同时通过本地缓存和分布式一致性机制进一步提升性能和稳定性。

#### 冷启动预热

当Redis刚启动或缓存失效后,如果有大量请求直打数据库,可能导致缓存穿透或缓存雪崩,所以需要提前把需要的热点数据装载进去

- **离线分析**：通过 MySQL 的慢查询日志、访问日志（如 Nginx/埋点日志），统计近期访问频率最高的前 10w 或 20w 数据，在服务启动时批量加载进 Redis。

- **定时预热**：每天凌晨/低峰期，重新统计热度 TopN，把最新的热点集更新到 Redis。

- **场景化预热**：例如电商大促，提前将商品详情页、秒杀商品库存等预写到 Redis。

#### 动态识别热点

业务的运行中动态的识别热点

- **热key框架**（如阿里开源的 hotkey、京东 hostkey）：拦截请求流量，统计 key 的访问频率，发现瞬时热点，自动上报并缓存。

- **服务端采样**：在应用层做 QPS 统计，使用滑动窗口计数（如 1s 内超过阈值则判定热点），然后把该 key 提前写入 Redis。

- **旁路代理识别**：Nginx/LVS/服务网关层可以做统计与识别，把流量热度同步给缓存层。

#### 淘汰机制收尾

Redis本身容量有限,所以要淘汰掉冷数据

- **LRU (Least Recently Used)**：默认策略，最近最少使用的淘汰，适合热点相对稳定的业务。
- **LFU (Least Frequently Used)**：按访问频率淘汰，更适合“热点突发”的场景。
- **合理 TTL**：对非永久性热点设置合适的过期时间，减少僵尸数据占用缓存。
- **分层 key 空间**：把真正核心的热点 key 放在单独的 Redis 实例，避免被淘汰。

#### 热点下沉到本地缓存

对于超级热点的key,可以下沉到本地缓存

#### 分布式一致性

- **热点 key 列表统一管理**：在 Redis/配置中心维护一份热 key 列表，各实例统一拉取。

- **失效同步**：通过 Redis Pub/Sub、Keyspace Notification、MQ 或 Canal 同步更新。

- **避免热点不一致**：如果不同服务实例各自识别热 key，可能导致缓存利用率下降。要做 **集中识别+分发**。

## 监控与报警

可以使用Redis自带的`hotkeys`命令结合监控系统(Prometheus + Grafana)报警

# 面试题

